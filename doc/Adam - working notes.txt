Current goal:

  - Maybe some simple compiler optimizations.

Bugs to fix:

  - Why does the UI crash after the "get a mirror on self" thing?

What compiler optimizations could I try first?

  - The most important ones, I'm guessing, will be the ones that help us avoid block cloning. That's causing us a lot of grief, with contorting the GC code and a lot of extra time spent in GC and stuff. So I think we're gonna want to:
    - Avoid cloning failblocks passed to primitives.
    - Do that type prediction thing where it knows that the call to ifTrue:False: is likely to be true or false, so it inlines those ones.
    - General inlining.
  - But ask Dave. He'll have ideas.

Speeding up the export cycle would be really nice. What's the strategy for that?

  - Speed up incremental update? (I don't really understand why it's slow. Try profiling it.)
  - Fix incremental update so that it can continue to work indefinitely.

Cleanups to do:

  - Addresses. Factor it all so that I can easily switch to untagged addresses.
  - Factor the layout stuff so that it's a bit more uniform and elegant about handling oops versus addresses. (C is really nice in that way; how close can we get to that?)
  - Stuff that tries to avoid cloning... is there a way to make it clear which stuff that is? Draw a clear fence around it? And avoid duplication with regular stuff? (The problem is that there's some stuff that needs failblocks when running on a remote image, but needs to avoid cloning when running in a local image.)

----

Dave's comments:

  - The most important optimization is inlining. It's a big one (and don't forget that it affects the debugger), but after that the regular optimization stuff is less important. (It can be addictive, though, so be careful not get sucked into doing just one more optimization.)
  - If I'm looking to port something to the iPhone, I might want to try the real Self VM, scary as it is.


----

For inlining, I think I need to:
  - Find the place where the compiler generates IR nodes for a send, and make sure the compiler knows when it knows the type of the receiver.
  - Think of a simple heuristic for deciding when to inline. Maybe "if it's a data slot or if the method is small", for now.
  - Find the places where the compiler creates IR nodes referring to the receiver or arguments or locals. Make sure they don't just do it by name, and then indirect them through a currentScope thing or something.

----

There's gotta be a way to avoid having to pull in the whole object table every time anything changes in it. Why not just pull in the parts we're accessing?

----

Remember to clean up the aaaaa things.

----

Stuff I want to do:

  - In the allocator, maybe initialize it right away with a vector of all 32 precolored register values. Then use those in the locationAssigner. (I think that's what the textbook wants me to do; maybe it makes a difference?)
  - Turn the miniVM into a really good test of the basic VM's capabilities. And unify that stuff with the midiVM/selfVM tests AND with the Self "tests" object.
  - Fix the compilerTester. Right, right - I broke it, made it require the compilationRequester.

----

http://selflanguage.org/_static/published/dynamic-deoptimization.pdf

So it looks like the deal is:

  - The compiler has to create scopeDesc information describing how the virtual stack frames are laid out within the physical stack frame.
  - Just to display the stack, no deoptimization is necessary - the debugger just has to pretend that the source-level stack frames are there (which it can do because of the scopeDesc info).
  - To deoptimize the topmost activation, just save a copy of the physical frame, pop it off, and then use the scopeDesc info to recreate source-level ones.
  - To deoptimize an activation in the middle of the stack, just wait for the stack to unwind back to that point and then deoptimize it. (Do that by making the return PC actually be to a procedure that'll deoptimize the thing.)
  - Need to have unoptimized nmethods either created on-the-fly or lying around, so that we can switch the PC into the right place in the unoptimized one and continue execution.
  - Use interrupt points (sends and backward branches) to interrupt a process. (They happen frequently, so there shouldn't be any major delay when you open up a debugger on a running process.) That way we can do source-level single-stepping by deoptimizing and then just setting the interrupt register. In between interrupt points, you can do any optimizations that won't wreck the ability to reconstruct the stack info at the next interrupt point.

That doesn't look so scary. And since we don't have source-level single-stepping or runtime changes yet anyway, I won't be breaking anything if I just implement inlining and make sure that the debugger can display stuff right. Cool!

----

Inlining plan:

  - Make dynamic compilation work inside Klein (even if it's really slow). (Shouldn't be too hard - maybe make the sendMessage_stub backpatch to call a lookupSlot_stub or something, which can be based on a generalized version of the code in compileSlotOn:Named:).
  - Turn static inlining off, except for a few specific slots that the exportPolicy can specify. Then figure out which stuff needs to be pre-inlined to make the system ramp up quickly enough.
  - Inline methods containing blocks. (The problem is that the block needs to be customized for each type of enclosing nmethod, since the enclosing nmethod might put the uplevel values in different places.) How about I have each nmethod keep a vector of the blocks that it uses (and clone each one of them from the original block literal)? And then add a constant VM slot to every block, containing a pointer to its value nmethod (or maybe to the enclosing nmethod)? (See forReflecteeOf:AddAllMappedVMSlotsTo:Mapper:.) That'll make sure that each block has a different map. Then I've just gotta make sure each one gets the right nmethod in its nmethod cache.
  - Inline other sends where we know the receiver type, not just self-sends.
  - In particular, inline block methods, so that we can eliminate the block. (We should have the lexicalParentAllocator lying around in the compiler object somewhere, since we're not gonna be inlining a block unless we've also inlined its lexical parent.)
