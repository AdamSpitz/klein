What compiler optimizations could I try first?

  - The most important ones, I'm guessing, will be the ones that help us avoid block cloning. That's causing us a lot of grief, with contorting the GC code and a lot of extra time spent in GC and stuff. So I think we're gonna want to:
    - Avoid cloning failblocks passed to primitives.
    - Do that type prediction thing where it knows that the call to ifTrue:False: is likely to be true or false, so it inlines those ones.
    - General inlining.
  - But ask Dave. He'll have ideas.

Speeding up the export cycle would be really nice. What's the strategy for that?

  - Speed up incremental update? (I don't really understand why it's slow. Try profiling it.)
  - Fix incremental update so that it can continue to work indefinitely.

Cleanups to do:

  - Addresses. Factor it all so that I can easily switch to untagged addresses.
  - Factor the layout stuff so that it's a bit more uniform and elegant about handling oops versus addresses. (C is really nice in that way; how close can we get to that?)
  - Stuff that tries to avoid cloning... is there a way to make it clear which stuff that is? Draw a clear fence around it? And avoid duplication with regular stuff? (The problem is that there's some stuff that needs failblocks when running on a remote image, but needs to avoid cloning when running in a local image.)

----

There's gotta be a way to avoid having to pull in the whole object table every time anything changes in it. Why not just pull in the parts we're accessing?

----

Remember to clean up the aaaaa and aaaaaaa things.

----

Stuff I want to do:

  - Turn the miniVM into a really good test of the basic VM's capabilities. And unify that stuff with the midiVM/selfVM tests AND with the Self "tests" object.
  - Fix the compilerTester. Right, right - I broke it, made it require the compilationRequester.

----

Hey, if I wanted to experiment with heap-allocated activations, so that I could compare the speed, how hard would that be? To make it easy to switch back and forth? (Or maybe even to have them both side by side?)

----

Does the leaf-method optimization have to be implemented using that backout-block thing? Can't we just keep going and then figure out at the end (maybe at the locationAssigner phase) whether we need a stack frame or not? Maybe we don't need to redo the whole compilation, just the locationAssigner.

----

I hope it's not compiling methods for regular blocks (as opposed to compiledBlocks).

----

Inlining plan:

  - Fix the bug in the source-level UI with inlined blocks.
  - Flesh out the list of stuff that needs to be pre-inlined to make the system ramp up quickly enough.

----

Whoa look at these nmethods we're compiling:
7129@a mirrors canonicalString(on 'compiledBlock!!!')@'parent'
7129@a mirrors canonicalString(on 'compiledBlock!!!')@'scopeDesc'
7129@a mirrors canonicalString(on 'compiledBlock!!!')@'originalBlock_replaceThisSlotWithTheValueSlot'

'Cause they've all got different maps. But... shouldn't the 'parent' nmethods be reusable? Oh - no, because they're really different slots, and the things are cached by slot and key, I think. Could I cache them by contents and key? No, not quite.


Also, is there anything I can do to make it cheaper to produce an nmethod for a constant slot? Right now, each nmethod for a constant slot costs:

  - Objects:
    - the nmethod itself
    - relocationInfo (which is of size 19 - the smiMap, the floatMap, the branch to the sendMessage_stub, and a loadAddress for the constant)
    - topScope
      - lookupKey

----

It's not cloning the block! Hooray! But now I've got this bug where the source-level UI crashes when inlined blocks are involved.

I've got a klein mirrors blockMethodActivation that gives me an error when I call lexicalParent on it.

----

Latest bug: see the picture.

With or without inlining, it looks like string canonicalization is broken. (Probably a symptom of some more fundamental problem.)
