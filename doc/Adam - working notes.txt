What compiler optimizations could I try first?

  - The most important ones, I'm guessing, will be the ones that help us avoid block cloning. That's causing us a lot of grief, with contorting the GC code and a lot of extra time spent in GC and stuff. So I think we're gonna want to:
    - Avoid cloning failblocks passed to primitives.
    - Do that type prediction thing where it knows that the call to ifTrue:False: is likely to be true or false, so it inlines those ones.
    - General inlining.
  - But ask Dave. He'll have ideas.

Speeding up the export cycle would be really nice. What's the strategy for that?

  - Speed up incremental update? (I don't really understand why it's slow. Try profiling it.)
  - Fix incremental update so that it can continue to work indefinitely.

Cleanups to do:

  - Addresses. Factor it all so that I can easily switch to untagged addresses.
  - Factor the layout stuff so that it's a bit more uniform and elegant about handling oops versus addresses. (C is really nice in that way; how close can we get to that?)
  - Stuff that tries to avoid cloning... is there a way to make it clear which stuff that is? Draw a clear fence around it? And avoid duplication with regular stuff? (The problem is that there's some stuff that needs failblocks when running on a remote image, but needs to avoid cloning when running in a local image.)

----

There's gotta be a way to avoid having to pull in the whole object table every time anything changes in it. Why not just pull in the parts we're accessing?

----

Remember to clean up the aaaaa and aaaaaaa things.

----

Stuff I want to do:

  - Turn the miniVM into a really good test of the basic VM's capabilities. And unify that stuff with the midiVM/selfVM tests AND with the Self "tests" object.
  - Fix the compilerTester. Right, right - I broke it, made it require the compilationRequester.

----

Hey, if I wanted to experiment with heap-allocated activations, so that I could compare the speed, how hard would that be? To make it easy to switch back and forth? (Or maybe even to have them both side by side?)

----

Does the leaf-method optimization have to be implemented using that backout-block thing? Can't we just keep going and then figure out at the end (maybe at the locationAssigner phase) whether we need a stack frame or not? Maybe we don't need to redo the whole compilation, just the locationAssigner.

----

I hope it's not compiling methods for regular blocks (as opposed to compiledBlocks).

----

Inlining plan:

  - Fix the bug in the source-level UI with inlined blocks.
  - Flesh out the list of stuff that needs to be pre-inlined to make the system ramp up quickly enough.

----

Now I've got this bug where the source-level UI crashes when inlined blocks are involved.

I've got a klein mirrors blockMethodActivation that gives me an error when I call lexicalParent on it.

----

Fix the copyright notices!!!

----

Call generatePrimitiveTranslationMethods when filing in the module, or something.

----

Um, why can't the normalReturnIndex in the sendDesc branch directly to the sourceSucc node? Why bother branching to the end of the send and then to the sourceSucc?

----

How hard would it be to do constant folding?

----

Awesome! The GC tests actually run. Now we fail during the compiling test.

Oh, no, now we're not actually failing, just running for a really long time. (Forever?) I opened up a debugger at a point where we seem to be in the middle of figuring out an object's reflective safeName. Which is needed for a comment. Maybe turn off areCommentsEmitted when we compile at runtime, at least for now?

Could also try inlining some of the fundamental things that I see in the stack - stuff needed by do: and stuff like that.

to:ByPositive:Do:
whileTrue:
loop
to:By:Do:
to:Do:
ifTrue:False:
ifTrue:
do:
value:With:
value:
value

shift
shiftPast
Oh, but to make that really help I might need constant folding.
Whoa, to get a mutable string's hash we canonicalize it and use its identityHash??? Maybe I shouldn't do that generating:During: thing.
maybe the set/dictionary stuff? Might not be necessary, though - fix the generating:During: thing first.

Dammit, fix the sender of nodeName.

Hmm, looks like shift is being inlined, but shiftPast isn't.

Hey, the compiling test finished!
