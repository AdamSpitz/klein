Current goal:

  - Maybe some simple compiler optimizations.

Bugs to fix:

  - Why does the UI crash after the "get a mirror on self" thing?

What compiler optimizations could I try first?

  - The most important ones, I'm guessing, will be the ones that help us avoid block cloning. That's causing us a lot of grief, with contorting the GC code and a lot of extra time spent in GC and stuff. So I think we're gonna want to:
    - Avoid cloning failblocks passed to primitives.
    - Do that type prediction thing where it knows that the call to ifTrue:False: is likely to be true or false, so it inlines those ones.
    - General inlining.
  - But ask Dave. He'll have ideas.

Speeding up the export cycle would be really nice. What's the strategy for that?

  - Speed up incremental update? (I don't really understand why it's slow. Try profiling it.)
  - Fix incremental update so that it can continue to work indefinitely.

Cleanups to do:

  - Addresses. Factor it all so that I can easily switch to untagged addresses.
  - Factor the layout stuff so that it's a bit more uniform and elegant about handling oops versus addresses. (C is really nice in that way; how close can we get to that?)
  - Stuff that tries to avoid cloning... is there a way to make it clear which stuff that is? Draw a clear fence around it? And avoid duplication with regular stuff? (The problem is that there's some stuff that needs failblocks when running on a remote image, but needs to avoid cloning when running in a local image.)

----

Dave's comments:

  - The most important optimization is inlining. It's a big one (and don't forget that it affects the debugger), but after that the regular optimization stuff is less important. (It can be addictive, though, so be careful not get sucked into doing just one more optimization.)
  - If I'm looking to port something to the iPhone, I might want to try the real Self VM, scary as it is.


----

For inlining, I think I need to:
  - Find the place where the compiler generates IR nodes for a send, and make sure the compiler knows when it knows the type of the receiver.
  - Think of a simple heuristic for deciding when to inline. Maybe "if it's a data slot or if the method is small", for now.
  - Find the places where the compiler creates IR nodes referring to the receiver or arguments or locals. Make sure they don't just do it by name, and then indirect them through a currentScope thing or something.

----

There's gotta be a way to avoid having to pull in the whole object table every time anything changes in it. Why not just pull in the parts we're accessing?

----

Remember to clean up the aaaaa things.

----

Stuff I want to do:

  - In the allocator, maybe initialize it right away with a vector of all 32 precolored register values. Then use those in the locationAssigner. (I think that's what the textbook wants me to do; maybe it makes a difference?)
  - Turn the miniVM into a really good test of the basic VM's capabilities. And unify that stuff with the midiVM/selfVM tests AND with the Self "tests" object.
  - Fix the compilerTester. Right, right - I broke it, made it require the compilationRequester.

----

http://selflanguage.org/_static/published/dynamic-deoptimization.pdf

So it looks like the deal is:

  - The compiler has to create scopeDesc information describing how the virtual stack frames are laid out within the physical stack frame.
  - Just to display the stack, no deoptimization is necessary - the debugger just has to pretend that the source-level stack frames are there (which it can do because of the scopeDesc info).
  - To deoptimize the topmost activation, just save a copy of the physical frame, pop it off, and then use the scopeDesc info to recreate source-level ones.
  - To deoptimize an activation in the middle of the stack, just wait for the stack to unwind back to that point and then deoptimize it. (Do that by making the return PC actually be to a procedure that'll deoptimize the thing.)
  - Need to have unoptimized nmethods either created on-the-fly or lying around, so that we can switch the PC into the right place in the unoptimized one and continue execution.
  - Use interrupt points (sends and backward branches) to interrupt a process. (They happen frequently, so there shouldn't be any major delay when you open up a debugger on a running process.) That way we can do source-level single-stepping by deoptimizing and then just setting the interrupt register. In between interrupt points, you can do any optimizations that won't wreck the ability to reconstruct the stack info at the next interrupt point.

That doesn't look so scary. And since we don't have source-level single-stepping or runtime changes yet anyway, I won't be breaking anything if I just implement inlining and make sure that the debugger can display stuff right. Cool!

----

Hey, if I wanted to experiment with heap-allocated activations, so that I could compare the speed, how hard would that be? To make it easy to switch back and forth? (Or maybe even to have them both side by side?)

----

Does the leaf-method optimization have to be implemented using that backout-block thing? Can't we just keep going and then figure out at the end (maybe at the locationAssigner phase) whether we need a stack frame or not? Maybe we don't need to redo the whole compilation, just the locationAssigner.

----

blockLiteralsThatWillNotBePushed - shouldn't that be done in a different way now?

----

Inlining plan:

  - Get the SSA stuff working, so we can inline other sends where we know the receiver type, not just self-sends.
  - Kleinify blocks; make them include a constant VM slot pointing to their enclosing scopeDesc.
  - Be able to inline block methods, so that we can eliminate the block.
  - Be able to inline methods containing blocks. (The problem is that the block needs to be customized for each type of enclosing nmethod, since the enclosing nmethod might put the uplevel values in different places.) How about I have each nmethod keep a vector of the blocks that it uses (and clone each one of them from the original block literal)? And then add a constant VM slot to every block, containing a pointer to its value nmethod (or maybe to the enclosing nmethod... no, to the *home scope* in the enclosing nmethod, because that's what I need to make NLRs work right!)? (See forReflecteeOf:AddAllMappedVMSlotsTo:Mapper:.) That'll make sure that each block has a different map. Then I've just gotta make sure each one gets the right nmethod in its nmethod cache.
  - Flesh out the list of stuff that needs to be pre-inlined to make the system ramp up quickly enough.

----

Whoa. Holy crap. The sendMessage_stub balloons up from 656 IR nodes to over 7000 when I turn on SSA.

I kinda like the "semi-pruned SSA" idea:   http://www.serc.iisc.ernet.in/cadl/courses/spe98-ssa.pdf

But only if it's actually true that a lot of variables are only used within the BB where they're defined. Might not be, considering that now every send ends the BB.

----

Hmm, it's running out of stack space during the SSA value-renaming thing, when it tries to compile that big long arithmetic (testSuccess?) method.

Can't tell whether it's an infinite loop or just really long. I'd be kinda surprised if it was infinite, though.

Oh, hey, looks like a big part of the problem is constructing the interference graph. Maybe it's time to use a more efficient data structure for that. Or do something different with the precolored values - seems like they're a big part of the problem. Yeah, don't mess with the data structures until I've fixed the algorithm.

Why did I do that precolored thing? The idea was that if V interferes with a precolored value, it interferes with *every* precolored value with that color. Yes, OK, sure... but when is that ever relevant? What do we use the interference information for?

Actually, maybe I could just use the alias mechanism? Treat the first precolored value (of a particular color) as the "real" one, and all the others as aliases. Then as long as we always do our interference checks using aliasOf:, we're fine. No?

Blecch. I mean, yes, fine, it might work, but I really hate this algorithm. It's a big mess. Hacks on top of hacks.

OK. It seems like my main problem is that I've got all these precolored values. I don't think I'm supposed to do that. Again, what if there was just one?

----

Working on the new linearScanLocationAssigner.

latest problem: gotta do the alias thing.

But to make it work right I'll have to set the live-intervals properly - it's gotta start at the start of the very first alias and end at the end of the very last one.

----

Let's talk out how this linearScanLocationAssigner is gonna work, get it really clear.

  - To start with, I've got:
    - allValues, all of which need to be assigned locations (though the unused ones can get any location they want and it doesn't really matter).
    - some of the values already have a location assigned to them
    - some of the values are aliases for other values, and need to be kept in the same location. (But they're still considered different *values* because the actual runtime value could be different.)
  - Then:
    - I determine the "live intervals" by finding the first place each value is defined and the last place it's used.
      - (The live intervals for aliases have to be merged into a single one that encompasses all of them.)
    - I run over the live intervals, keeping track of which intervals are live at the same time.
      - I assign each of them a location as I go, chosen from the pool of available registers. (If there's none available I just spill it, or maybe spill a different one if I think that one will cost less to spill.)
        - But to do that, I need to be sure that it's *OK* to spill that one - that that one wasn't a preallocated or aliased one.
          - Now, the aliased ones should all have a single merged live range... but I still need to make sure, when I reassign it, that I reassign *all* of them. ***** I think I might not be doing that.
          - And I'm not allowed to reassign a preallocated one at all. ***** Not sure I'm doing that properly, either.

Maybe I shouldn't actually assign a location to the value objects as I go along - maybe I should hold the location inside the interval object, and then assign them to the values in a separate pass when I'm done. That'd let me keep track of the difference between preallocated and non-preallocated.

----

Aha! I get the bug. There are a bunch of unused and undefined values (presumably the ones that got renamed). The location assigner sees that the live interval is (maxSmallInt, -1) and thinks it's OK to assign it to the same location as whatever else it wants.

So maybe the thing that inserts the moves shouldn't bother if the thing has no users or definers.

----

Screw this. Maybe I should go back to the graphColoring one. I think I just need to explicitly represent the equivalence classes - make sure that the interference graph never includes aliases, only the canonical one or the eqivalenceClass object or something.

----

Gotta fix the aaaaaaa's - at least the one about reusing the scopeDesc nmethod.

----

Whoa, I think it worked!

Time to lift the ban on inlining methods containing blocks? And then later on inlining block methods.
