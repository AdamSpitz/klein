# include "lookup.hh"
# include "map.hh"
# include "stringObj.hh"
# include "activation.hh"


// todo optimize space Should we save map space by not having separate SDs for assignment slots? -- dmu 12/06

Lookup::Result* Lookup::findSlotsIn( oop_t rcvr, oop_t selector, LookupType lt ) {
  static bool reentered = false;
  if (reentered) fatal("reentered");
  reentered = true;
  
  static Lookup lp;
  lp.init(selector, lt);
  if (baseLookupType(lt) == ResendBaseLookupType)   lp.findInParentsOf(rcvr, MapObj::from(mapOop(rcvr)));
  else                                              lp.findInObject(rcvr);
  
  reentered = false;
  return &lp.result;
}

void Lookup::selectorAndSourceForLookupError (Result::result_type rt, oop_t& sel, char*& source) {
 switch (rt) {
  case Result::foundNone: 
    sel = StringObj::intern( "undefinedSelector:Receiver:Type:Delegatee:MethodHolder:Arguments:");
    source = "\n\"undefined selector error;\nthis method was automatically generated by the VM.\"\n";
    break;
  
  case Result::foundOne: 
    fatal ("Should not reach here");
    break;

  case Result::foundTwo: 
    sel = StringObj::intern( "ambiguousSelector:Receiver:Type:Delegatee:MethodHolder:Arguments:");
    source = "\n\"undefined selector error;\nthis method was automatically generated by the VM.\"\n";
    break;

    
/*
   case delegateeNotFound:
    sel = VMString[MISSINGPARENTSELECTOR_RECEIVER_TYPE_DELEGATEE_METHODHOLDER_ARGUMENTS_];
    source = "\n\"missing parent error;\nthis method was automatically generated by the VM.\"\n";
    break;

   case foundAssignableParent:
   case resendUndecidable:
    ShouldNotReachHere(); // run-time lookup failing w/ a compile-time condition

   case mismatchedArgCount:
    sel = VMString[MISMATCHEDARGUMENTCOUNTSELECTOR_RECEIVER_TYPE_DELEGATEE_METHODHOLDER_ARGUMENTS_];
    source = "\n\"mismatched argument count error;\nthis method was automatically generated by the VM.\"\n";
    break;

   case performTypeError:
    sel = VMString[PERFORMTYPEERRORSELECTOR_RECEIVER_TYPE_DELEGATEE_METHODHOLDER_ARGUMENTS_];
    source = "\n\"perform type error;\nthis method was automatically generated by the VM.\"\n";
    break;
*/
   default:
    fatal ("should not reach here"); // unknown status
  }    
  
}


oop_t Lookup::messageTypeForLookupError(LookupType lookupType) {
  // todo optimize time: put these strings in The. -- Adam, 5/06
  
  switch (baseLookupType(lookupType)) {
   case NormalBaseLookupType:
     if (isImplicitSelfLookupType(lookupType))
       return StringObj::intern("implicitSelf");
     else
       return StringObj::intern("normal");
   case ResendBaseLookupType:
     return StringObj::intern("undirectedResend");
   case DirectedResendBaseLookupType:
     return StringObj::intern("directedResend");
   case DelegatedBaseLookupType:
     return StringObj::intern("delegated");
   default:
     fatal("should not reach here");
     return badOop;
  }
}

const fint MAX_ARGS = 100;
fint Lookup::argCountForLookupError(oop_t selector, fint perform_arg_count, LookupType lookupType) {
  fint argc;

  if (isPerformLookupType(lookupType)) {
    assert(perform_arg_count >= 0); // should have a static selector or a perform arg count
    argc = perform_arg_count;
  } else {
    assert(is_byteVector(selector)); // should be a string if static
    argc = ByteVectorObj::from(selector)->arg_count();
  }
  assert(argc >= 0 && argc < MAX_ARGS);
  return argc;
}

oop_t Lookup::lookupFailed(oop_t rcvr, oop_t sel, oop_t del, oop_t holder_of_sender_method, oop_t sender_act, LookupType lookupType, Result::result_type rt) {
  oop_t selForError;
  char* sourceForError;
  selectorAndSourceForLookupError(rt, selForError, sourceForError);

  oop_t holder_of_error_method;
  oop_t rcvr_for_error_method = The::oop_of(The::process_proto); // todo processes need to get the current process
  oop_t error_method = findObject( rcvr_for_error_method, selForError, &holder_of_error_method );
  if (error_method == badOop) {
    printf("Lookup failed - "); StringObj::from(sel)->string_print(); printf("\n");
    printf("And looking up error selector failed - "); StringObj::from(selForError)->string_print(); printf("\n");
    unimplemented("lookup failure: could not find original selector and could not find error selector either");
    return badOop;
  }
  
  assert( holder_of_sender_method != badOop );
  oop_t msgType = messageTypeForLookupError(lookupType);
  oop_t vector_of_original_args = ActivationObj::from(sender_act)->vector_of_outgoing_arguments(ByteVectorObj::from(sel)->arg_count(), isImplicitSelfLookupType(lookupType));

  assert(ByteVectorObj::from(selForError)->arg_count() == 6); // Selector:Receiver:Type:Delegatee:MethodHolder:Arguments:
  oop_t args_to_lookup_error_method[6];
  args_to_lookup_error_method[0] = selForError;
  args_to_lookup_error_method[1] = rcvr;
  args_to_lookup_error_method[2] = msgType;
  args_to_lookup_error_method[3] = del;
  args_to_lookup_error_method[4] = holder_of_sender_method;
  args_to_lookup_error_method[5] = vector_of_original_args;
  
  // todo should really create a new method sending the error message
  return ActivationObj::clone_for(error_method, holder_of_error_method, rcvr_for_error_method, args_to_lookup_error_method, 6, sender_act);  
  
/*
  // Create a method sending the lookup error message to the
  // current process.
  ByteCode b(true);
  slotList* slots = EMPTY;

  // push the receiver of the method send
  b.GenSendByteCode(0, 0, new_string("_ThisProcess"), true, false, NULL);

  // push the arguments
  
  // First push the selector. Must put it in a slot because
  // for a perform type error, it might be a block with an uplevel access.
  // That confuses the fixup code, which expects block literals to be lexically part of this method.
  // So, replaced   b.GenLiteralByteCode(0, 0, selector()); 
  // with: (dmu 1/03)
  stringOop attemptedSelector = new_string("selector");
  slots = slots->add( attemptedSelector, map_slotType, selector());
  b.GenSendByteCode(0, 0, attemptedSelector, true, false, NULL);

  b.GenSelfByteCode(0, 0);
  
  b.GenLiteralByteCode(0, 0, msgType);
  
  b.GenLiteralByteCode(0, 0,
                       delegatee() == NULL ? Memory->nilObj : delegatee());
  
  assert_methodHolder_is_object();
  assert(!methodHolder_or_map()->has_code(),
         "method holder shouldn't have code");
  
  stringOop del = new_string("delegatee");
  slots = slots->add( del, map_slotType,
                      isResendLookupType(lookupType())
                      ? methodHolder_or_map() : Memory->nilObj);
  b.GenSendByteCode(0, 0, del, true, false, NULL);
  
  // create vector to hold args: "vector _Clone: arc _FillingWith: nil"
  b.GenLiteralByteCode(0, 0, Memory->objVectorObj);
  b.GenLiteralByteCode(0, 0, as_smiOop(argc));
  b.GenLiteralByteCode(0, 0, Memory->nilObj);
  b.GenSendByteCode(0, 0, VMString[_CLONE_FILLER_], false, false, NULL);
  
  // also cons up arg names, add arg slots, get args into stack
  for (fint i = 0; i < argc; i++) {
    // make argNameOop
    char argName[20];
    sprintf(argName, "arg%ld", (long)i + 1);
    stringOop arg = new_string(argName);
    
    // make slot and store arg in vector
    slots = slots->add(arg, arg_slotType, as_smiOop(i));
    
    // <vector> at: i Put: <arg>
    b.GenLiteralByteCode(0, 0, as_smiOop(i));
    b.GenSendByteCode(0, 0, arg, true, false, NULL);
    b.GenSendByteCode(0, 0, VMString[_AT_PUT_], false, false, NULL);
  }
  
  // send the message to the receiver.
  b.GenSendByteCode(0, 0, sel, false, false, NULL);
  
  // NB: don't change <error> below without consulting recompile.c;
  // the code there uses it to recognize these weird methods.  Should
  // really be a flag somewhere
  bool ok = b.Finish("<error>", source);
  assert(ok, "no errors here");

  slotsOop method= create_outerMethod(slots, &b);
  setResult(method);*/
}

oop_t Lookup::findObject( oop_t rcvr,
                          oop_t sel,
                          oop_t* holderp,
                          SlotDesc** sdp,
                          oop_t* lookup_failed_act_addr,
                          oop_t sender_act,
                          bool isUndirectedResend,
                          oop_t delegatee,
                          oop_t holder_of_sender_method,
                          bool isSelfImplicit ) {
                          
  BaseLookupType blt = isUndirectedResend   ?         ResendBaseLookupType
                     : delegatee            ? DirectedResendBaseLookupType
                                            :         NormalBaseLookupType;
  LookupType lt = blt | (isSelfImplicit ? ImplicitSelfBit : 0);
  
  oop_t lookup_start = isUndirectedResend ?              holder_of_sender_method
                     : delegatee          ? MemObj::from(holder_of_sender_method)->contents_of_slot(delegatee)
                     : rcvr;

  Result* r = findSlotsIn(lookup_start, sel, lt);
  if (r->rt != Lookup::Result::foundOne) {
    if (lookup_failed_act_addr == NULL) {
      printf("Lookup failed - "); StringObj::from(sel)->string_print(); printf("\n");
      fatal("Lookup failed that was not expected to fail");
    } else {
      *lookup_failed_act_addr = lookupFailed(rcvr, sel, delegatee, holder_of_sender_method, sender_act, lt, r->rt);
    }
    return badOop;
  }
  oop_t holder = r->refs[0].holder;

  if (holderp) {
    *holderp = holder;
    if (sdp)
      *sdp = r->refs[0].sd;
  }
  return r->refs[0].sd->contents(holder);
}


void Lookup::findInObject(oop_t r) {
  MapObj* m_addr = MapObj::from(mapOop(r));
  if (m_addr->lookup_is_marked())
    return;
  m_addr->lookup_mark();
  
  SlotDesc* sd = m_addr->find_slot(selector);
  if (sd != NULL)
    result.add_slot(r, sd);
  else
    findInParentsOf(r, m_addr);
  m_addr->lookup_unmark();
}


void Lookup::findInParentsOf(oop_t r, MapObj* m_addr) {
  // todo optimize time should put parent slots in front -- dmu 1/06
  FOR_EACH_PARENT_SLOT_DESC(m_addr, sd) {
    oop_t parent = sd->contents(r);
    findInObject(parent);
    if (result.rt == Result::foundTwo)
      return;
  }
}


void Lookup::Result::add_slot(oop_t holder, SlotDesc* sd) {
  switch (rt) {
   case foundNone:
    refs[0].sd = sd;
    refs[0].holder = holder;
    rt = foundOne;
    break;
    
   case foundOne:
    if (refs[0].sd == sd)
      break;
    refs[1].sd = sd;
    refs[1].holder = holder;
    rt = foundTwo;
    break;
    
   default:
    fatal("impossible");
  }
}

